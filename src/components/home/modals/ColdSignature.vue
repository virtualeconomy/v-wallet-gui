<template>
  <div>
    <div v-if="!isScanPage && !isTotalScan">
      <p>Scan with cold wallet before continuing</p>
      <div id="address-qrcode">
        <img id="qr-image"
             :src="getBaseQrCodeImg">
        <br>
        <span>Current Page: {{ qrPage + 1 }} Total Page: {{ qrTotalPage }}</span>
      </div>
      <b-row>
        <b-col class="col-lef">
          <b-button
            class="btn-back"
            block
            variant="light"
            size="lg"
            @click="getPrevious">Back
          </b-button>
        </b-col>
        <b-col class="col-rit">
          <b-button
            block
            class="btn-confirm"
            variant="warning"
            size="lg"
            @click="getQrCodeImg()">Continue
          </b-button>
        </b-col>
      </b-row>
    </div>
    <div v-if="isScanPage && isTotalScan">
      <div class="qr-info">Show the QR code generated by your cold wallet client.</div>
      <div class="qr-window">
        <qrcode-reader @init="onInit"
                       @decode="onDecode"
                       :track="repaintLocation"
                       :paused="paused">
          <img v-if="qrInit"
               class="qrcode-waiting center"
               height="80"
               width="80"
               src="../../../assets/imgs/icons/wallet/ic_wait.svg">
        </qrcode-reader>
      </div>
      <div class="flink"
           v-if="qrError">
        <div class="qr-invalid">
          <p v-if="protocolError">Wrong Protocol. Please</p>
          <p v-else-if="opcError">Wrong Opc. Please</p>
          <p v-else-if="apiError">Wrong Api. Please</p>
          <P v-else-if="sgError">Invalid Signature. Please</P>
          <p v-else>Wrong QRCode. Please</p>
        </div>
        <b-button
          class="blink"
          @click="scanAgain"
          variant="link">
          scan again
        </b-button>
        .
      </div>
      <b-button variant="warning"
                class="btn-continue"
                size="lg"
                block
                :disabled="qrInit"
                @click="prevPage">Back
      </b-button>
    </div>
  </div>
</template>

<script>
import jrQrcode from 'jr-qrcode'
import crypto from '../../../utils/crypto'
import BigNumber from 'bignumber.js'
import { API_VERSION, PROTOCOL, OPC_SIGNATURE, OPC_FUNCTION, OPC_CONTRACT } from '@/constants.js'
import transaction from '../../../utils/transaction'
export default {
    name: 'ColdSignature',
    data: function() {
        return {
            isTotalScan: false,
            qrPage: 0,
            qrInit: false,
            paused: false,
            signature: '',
            scanShow: false,
            isScanPage: false,
            qrError: false,
            sgError: false,
            apiError: false,
            protocolError: false,
            opcError: false
        }
    },
    props: {
        qrArray: {
            type: Array,
            default: function() {
            }
        },
        qrTotalPage: {
            type: Number,
            default: 1
        },
        dataObject: {
            type: Object,
            require: true,
            default: function() {}
        }
    },
    computed: {
        getBaseQrCodeImg() {
            const options = {
                padding: 10,
                width: 256,
                height: 256,
                correctLevel: 2,
                reverse: false,
                background: '#ffffff',
                foreground: '#000000'
            }
            var text = ''
            if (this.qrTotalPage === 1) {
                let data = JSON.parse(JSON.stringify(this.dataObject))
                if (data.opc === OPC_FUNCTION) {
                    delete data.senderPublicKey
                }
                text = JSON.stringify(data).replace(/"amount":"(\d+)"/g, '"amount":$1')
            } else {
                let tempData = JSON.parse(JSON.stringify(this.dataObject))
                if (tempData.opc === OPC_CONTRACT) {
                    delete tempData.senderPublicKey
                }
                let checkSum = crypto.sha256ForCheckSum(JSON.stringify(tempData))
                text = 'Seg/' + (this.qrPage + 1) + '/' + this.qrTotalPage + '/' + checkSum + '/'
                text += this.qrArray[this.qrPage]
            }
            const imgBase64 = jrQrcode.getQrBase64(text, options)
            return imgBase64
        }
    },
    methods: {
        getQrCodeImg() {
            if (this.qrPage < this.qrTotalPage - 1) {
                this.qrPage++
                document.getElementById('qr-image').src = this.getBaseQrCodeImg
            } else {
                this.isTotalScan = true
                this.nextPage()
            }
        },
        getPrevious() {
            if (this.qrPage > 0) {
                this.qrPage--
                document.getElementById('qr-image').src = this.getBaseQrCodeImg
            } else {
                this.prevPage()
            }
        },
        async onInit(promise) {
            try {
                this.qrInit = true
                this.qrError = false
                this.protocolError = false
                this.apiError = false
                this.sgError = false
                this.opcError = false
                await promise
            } catch (error) {
                if (error.name === 'NotAllowedError') {
                    throw Error('user denied camera access permission')
                } else if (error.name === 'NotFoundError') {
                    throw Error('no suitable camera device installed')
                } else if (error.name === 'NotSupportedError') {
                    throw Error('page is not served over HTTPS (or localhost)')
                } else if (error.name === 'NotReadableError') {
                    throw Error('maybe camera is already in use')
                } else if (error.name === 'OverconstarinedError') {
                    throw Error('pass constraints do not match any camera')
                } else {
                    throw Error('browser is probably lacking features(WebRTC, Canvas)')
                }
            } finally {
                this.qrInit = false
            }
        },
        scanChange: function() {
            this.scanShow = !this.scanShow
        },
        onDecode: function(decodeString) {
            this.paused = true
            this.qrError = false
            this.protocolError = false
            this.apiError = false
            this.sgError = false
            this.opcError = false
            try {
                var jsonObj = JSON.parse(decodeString)
                var opc = jsonObj.opc
                var api = jsonObj.api
                var protocol = jsonObj.protocol
                var signature = jsonObj.signature
                if (!signature) {
                    this.paused = false
                    this.sgError = true
                    this.qrError = true
                } else {
                    var data = JSON.parse(JSON.stringify(this.dataObject))
                    if (api > API_VERSION) this.apiError = true
                    if (protocol !== PROTOCOL) this.protocolError = true
                    if (opc !== OPC_SIGNATURE) this.opcError = true
                    delete data.transactionType
                    delete data.api
                    var dataOpc = data.opc
                    delete data.opc
                    delete data.protocol
                    if (dataOpc === OPC_FUNCTION || dataOpc === OPC_CONTRACT) {
                        data.fee = BigNumber(data.fee)
                        data.timestamp = BigNumber(data.timestamp *= 1e6)
                    } else {
                        data.timestamp *= 1e6
                    }
                    if ((((dataOpc !== OPC_FUNCTION) && transaction.isValidSignature(data, signature, this.dataObject.senderPublicKey, this.dataObject.transactionType)) ||
                        ((dataOpc === OPC_FUNCTION) && transaction.isValidContractExecSignature(data, signature, data.senderPublicKey)) ||
                        ((dataOpc === OPC_CONTRACT) && transaction.isValidContractSignature(data, signature, data.senderPublicKey))) && !this.qrError) {
                        var _this = this
                        setTimeout(function() {
                            _this.$emit('get-signature', signature)
                        }, 300)
                    } else {
                        this.sgError = true
                    }
                    if (this.sgError || this.apiError || this.opcError || this.protocolError) this.qrError = true
                }
            } catch (e) {
                this.paused = false
                this.qrError = true
            }
        },
        scanAgain: function() {
            this.paused = false
            this.qrError = false
            this.protocolError = false
            this.apiError = false
            this.sgError = false
            this.opcError = false
        },
        prevPage: function() {
            if (this.isScanPage) {
                this.isScanPage = false
                this.isTotalScan = false
            } else {
                this.$emit('prev-page')
            }
        },
        nextPage: function() {
            this.isScanPage = true
            this.paused = false
        },
        repaintLocation(location, ctx) {
            if (location !== null) {
                const {
                    topLeftCorner,
                    topRightCorner,
                    bottomLeftCorner,
                    bottomRightCorner
                } = location
                ctx.strokeStyle = 'orange' // instead of red
                ctx.beginPath()
                ctx.moveTo(topLeftCorner.x, topLeftCorner.y)
                ctx.lineTo(bottomLeftCorner.x, bottomLeftCorner.y)
                ctx.lineTo(bottomRightCorner.x, bottomRightCorner.y)
                ctx.lineTo(topRightCorner.x, topRightCorner.y)
                ctx.lineTo(topLeftCorner.x, topLeftCorner.y)
                ctx.closePath()
                ctx.stroke()
            }
        }
    }
}
</script>

<style scoped>
#address-qrcode {
    margin-top: 30px;
    text-align: center;
    margin-bottom: 40px;
}
.qrcode-waiting {
    vertical-align: middle;
    display: flex;
    margin-top: 10px;
    margin-right: auto;
    margin-left: auto;
    margin-bottom: 30px;
}
.qr-window {
    padding: 30px 100px;
}
.qr-info {
    text-align: center;
}
.btn-confirm {
    height: 44px;
    font-size: 17px;
    color: #FFFFFF;
    letter-spacing: 0;
    text-align: center;
}
.btn-back {
    background: #FAFAFA;
    border: 1px solid #E8E9ED;
    border-radius: 4px;
    font-size: 17px;
    color: #4F515E;
    letter-spacing: 0;
    text-align: center;
}
.col-lef {
    padding-right: 10px;
}
.col-rit {
    padding-left: 10px;
}
.blink {
    display: inline-block;
    padding-top: 3px;
    padding-left: 0px;
    padding-right: 0px;
}
.flink {
    display: inline-block;
    margin-top: 0px;
    margin-bottom: 20px;
}
.qr-invalid {
    margin-left: 80px;
    display: inline-block;
}
.btn-continue {
    font-size: 17px;
    color: #FFFFFF;
    letter-spacing: 0;
    text-align: center;
    height: 50px;
}
</style>
